'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});
exports.find = find;
exports.findAsPromise = findAsPromise;

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _rx = require('rx');

var _rx2 = _interopRequireDefault(_rx);

var _globby = require('globby');

var _globby2 = _interopRequireDefault(_globby);

var _arrify = require('arrify');

var _arrify2 = _interopRequireDefault(_arrify);

var _fs = require('fs');

var _stringSearch = require('string-search');

var stringSearcher = _interopRequireWildcard(_stringSearch);

var _path = require('path');

var _bluebird = require('bluebird');

function find() {
  var searchPatterns = arguments.length <= 0 || arguments[0] === undefined ? [] : arguments[0];
  var includePatterns = arguments.length <= 1 || arguments[1] === undefined ? '**' : arguments[1];
  var options = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];

  var searchPatternsArr = (0, _arrify2['default'])(searchPatterns);
  var includePatternsArr = (0, _arrify2['default'])(includePatterns || ['**']); //if includePatterns is null or undefined, consider all files
  var opts = options || {}; //needed if user sends in a null
  opts.nodir = true; //needed by node-glob to omit dir match paths
  if (searchPatternsArr.length < 1) {
    //return error observable that sends down an error.
    return _rx2['default'].Observable['throw'](new TypeError('You must provide at least one search pattern'));
  }

  var filePathsObs = filePathsStream(includePatternsArr, options);
  var filePathObs = filePathStream(filePathsObs);
  var fileContentObs = fileContentStream(filePathObs, opts.cwd);
  var contentAndSearchStringObs = contentAndSearchStringStream(fileContentObs, searchPatternsArr);
  var resultsObs = resultsStream(contentAndSearchStringObs);
  var nonEmptyResultsObs = nonEmptyResultsStream(resultsObs);
  var flatResultObs = flatResultStream(nonEmptyResultsObs);

  return flatResultObs;
}

function findAsPromise(searchPatterns, includePatterns, options) {
  return new _bluebird.Promise(function (resolve, reject) {
    find(searchPatterns, includePatterns, options).toArray().subscribe(function (results) {
      return resolve(results);
    }, function (err) {
      return reject(err);
    });
  });
}

// input - include patterns array, and options
// output - string array of paths observable
function filePathsStream(includePatternsArr, options) {
  var dirPromise = (0, _globby2['default'])(includePatternsArr, options);
  return _rx2['default'].Observable.fromPromise(dirPromise);
}

// input - String array of paths observable
// output - string paths observable
function filePathStream(filePathsObs) {
  return filePathsObs.flatMap(function (arr) {
    return _rx2['default'].Observable.from(arr);
  });
}

// input - string paths observable
// output - file content observable
function fileContentStream(filePathObs) {
  var baseDir = arguments.length <= 1 || arguments[1] === undefined ? '' : arguments[1];

  return filePathObs.flatMap(function (filePath) {
    var readFileObs = _rx2['default'].Observable.fromNodeCallback(_fs.readFile);
    var actualFilePath = (0, _path.join)(baseDir, filePath);
    return readFileObs(actualFilePath, 'utf-8').map(function (content) {
      return { file: filePath, content: content };
    });
  });
}

// input - file content observable, query string array
// output - file content and query string observable
function contentAndSearchStringStream(fileContentObs, searchTerms) {
  return fileContentObs.flatMap(function (fileObj) {
    return _rx2['default'].Observable['for'](searchTerms, function (searchTerm) {
      return _rx2['default'].Observable['return']({ file: fileObj.file, content: fileObj.content, term: searchTerm });
    });
  });
}

// input - content and query string observable
// output - results object observable (containing matches and file attributes that could contain empty arrays
function resultsStream(contentAndSearchStringObs) {
  return contentAndSearchStringObs.flatMap(function (obj) {
    var resultsPromisesObs = _rx2['default'].Observable.fromPromise(stringSearcher.find(obj.content, obj.term));
    return resultsPromisesObs.zip(function (resultsArr) {
      return { matches: resultsArr, file: obj.file };
    });
  });
}

// input - results array observable that could contain empty arrays
// output - results array observable without empty arrays
function nonEmptyResultsStream(resultsObs) {
  return resultsObs.filter(function (resultObj) {
    return resultObj.matches.length > 0;
  });
}

// input - cleaned up results array observable
// output - individual flat object results observable
function flatResultStream(nonEmptyResultsObs) {
  return nonEmptyResultsObs.flatMap(function (obj) {
    return _rx2['default'].Observable['for'](obj.matches, function (match) {
      return _rx2['default'].Observable['return']({ file: obj.file, line: match.line, term: match.term, text: match.text });
    });
  });
}